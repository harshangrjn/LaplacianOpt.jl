var documenterSearchIndex = {"docs":
[{"location":"function_references/#LaplacianOpt.jl-Function-References","page":"Function References","title":"LaplacianOpt.jl Function References","text":"","category":"section"},{"location":"function_references/","page":"Function References","title":"Function References","text":"Modules = [LaplacianOpt]","category":"page"},{"location":"function_references/#LaplacianOpt.GraphData","page":"Function References","title":"LaplacianOpt.GraphData","text":"GraphData\n\nThe composite mutable struct, GraphData, holds matrices of adjacency matrix, laplacian matrix, fiedler vector and algebraic connectivity.\n\n\n\n\n\n","category":"type"},{"location":"function_references/#LaplacianOpt.LaplacianOptModel","page":"Function References","title":"LaplacianOpt.LaplacianOptModel","text":"LaplacianOptModel\n\nThe composite mutable struct, LaplacianOptModel, holds dictionaries for input data, abstract JuMP model for optimization, variable references and result from solving the JuMP model.\n\n\n\n\n\n","category":"type"},{"location":"function_references/#LaplacianOpt._catch_data_input_error-Tuple{Int64, Int64, Int64, Number}","page":"Function References","title":"LaplacianOpt._catch_data_input_error","text":"_catch_data_input_error(num_nodes::Int64, i::Int64, j::Int64, w_ij::Number)\n\nGiven the number of nodes, from and to nodes of an edge, and an edge weight, this function catches  any input data error in the JSON file. \n\n\n\n\n\n","category":"method"},{"location":"function_references/#LaplacianOpt._detect_infeasbility_in_data-Tuple{Dict{String, Any}}","page":"Function References","title":"LaplacianOpt._detect_infeasbility_in_data","text":"_detect_infeasbility_in_data(data::Dict{String, Any})\n\nGiven the pre-processed data dictionary, this function detects any infeasibility before  building the optimization model. \n\n\n\n\n\n","category":"method"},{"location":"function_references/#LaplacianOpt._is_flow_cut_valid-Tuple{Vector{Int64}, Vector{Int64}, Int64, Array{<:Number}}","page":"Function References","title":"LaplacianOpt._is_flow_cut_valid","text":"_is_flow_cut_valid(cutset_f::Vector{Int64}, cutset_t::Vector{Int64}, adjacency::Array{<:Number})\n\nGiven from and to sets of vertices of connected components of a graph, this function returns a  boolean if the input num_edges number of candidate edge exist to augment or not, between these two sets of vertices. \n\n\n\n\n\n","category":"method"},{"location":"function_references/#LaplacianOpt._violated_eigen_vector-Tuple{Array{<:Number}}","page":"Function References","title":"LaplacianOpt._violated_eigen_vector","text":"_violated_eigen_vector(W::Array{<:Number}; tol = 1E-6)\n\nGiven a square symmetric matrix, this function returns an eigen vector corresponding to it's most  violated eigen value w.r.t positive semi-definiteness of the input matrix.  \n\n\n\n\n\n","category":"method"},{"location":"function_references/#LaplacianOpt.algebraic_connectivity-Tuple{Array{<:Number}}","page":"Function References","title":"LaplacianOpt.algebraic_connectivity","text":"algebraic_connectivity(adjacency_matrix::Array{<:Number})\n\nReturns the algebraic connectivity or the   second smallest eigenvalue of the Laplacian matrix, for an input weighted adjacency matrix of the graph. \n\n\n\n\n\n","category":"method"},{"location":"function_references/#LaplacianOpt.fiedler_vector-Tuple{Array{<:Number}}","page":"Function References","title":"LaplacianOpt.fiedler_vector","text":"fiedler_vector(adjacency_matrix::Array{<:Number})\n\nReturns the Fiedler vector or the eigenvector corresponding to the  second smallest eigenvalue of the Laplacian matrix for an input weighted adjacency matrix of the graph. \n\n\n\n\n\n","category":"method"},{"location":"function_references/#LaplacianOpt.get_data-Tuple{Dict{String, Any}}","page":"Function References","title":"LaplacianOpt.get_data","text":"get_data(params::Dict{String, Any})\n\nGiven the input params, this function preprocesses the data, catches any error and missing data,  and outputs a detailed dictionary which forms the basis for building an optimization model. \n\n\n\n\n\n","category":"method"},{"location":"function_references/#LaplacianOpt.get_objective_bound-Tuple{JuMP.Model}","page":"Function References","title":"LaplacianOpt.get_objective_bound","text":"\n\n\n\n","category":"method"},{"location":"function_references/#LaplacianOpt.get_objective_value-Tuple{JuMP.Model}","page":"Function References","title":"LaplacianOpt.get_objective_value","text":"\n\n\n\n","category":"method"},{"location":"function_references/#LaplacianOpt.get_rounded_zeros_and_ones!-Tuple{Array{<:Number}}","page":"Function References","title":"LaplacianOpt.get_rounded_zeros_and_ones!","text":"get_rounded_zeros_and_ones!(v::Array{<:Number}; tol = 1E-6)\n\nGiven a vector of numbers, this function updates the input vector by rounding the values closest to 0, 1 and -1. \n\n\n\n\n\n","category":"method"},{"location":"function_references/#LaplacianOpt.laplacian_matrix-Tuple{Array{<:Number}}","page":"Function References","title":"LaplacianOpt.laplacian_matrix","text":"laplacian_matrix(adjacency_matrix::Array{<:Number})\n\nGiven a weighted adjacency matrix as an input, this function returns the  weighted Laplacian matrix of the graph. \n\n\n\n\n\n","category":"method"},{"location":"function_references/#LaplacianOpt.logger_config!-Tuple{Any}","page":"Function References","title":"LaplacianOpt.logger_config!","text":"allows the user to set the logging level without the need to add Memento\n\n\n\n\n\n","category":"method"},{"location":"function_references/#LaplacianOpt.optimal_graph_edges-Tuple{Array{<:Number}}","page":"Function References","title":"LaplacianOpt.optimal_graph_edges","text":"optimal_graph_edges(adjacency_matrix::Array{<:Number})\n\nReturns a vector of tuples of edges corresponding  to an input adjacency matrix of the graph. \n\n\n\n\n\n","category":"method"},{"location":"function_references/#LaplacianOpt.relaxation_bilinear-Tuple{JuMP.Model, JuMP.VariableRef, JuMP.VariableRef, JuMP.VariableRef}","page":"Function References","title":"LaplacianOpt.relaxation_bilinear","text":"relaxation_bilinear(m::JuMP.Model, xy::JuMP.VariableRef, x::JuMP.VariableRef, y::JuMP.VariableRef)\n\nGeneral relaxation of a binlinear term using McCormick relaxations. This can be used to obtain specific variants  in partiuclar cases of variables (when either or both the variables are binary)\n\nz >= JuMP.lower_bound(x)*y + JuMP.lower_bound(y)*x - JuMP.lower_bound(x)*JuMP.lower_bound(y)\nz >= JuMP.upper_bound(x)*y + JuMP.upper_bound(y)*x - JuMP.upper_bound(x)*JuMP.upper_bound(y)\nz <= JuMP.lower_bound(x)*y + JuMP.upper_bound(y)*x - JuMP.lower_bound(x)*JuMP.upper_bound(y)\nz <= JuMP.upper_bound(x)*y + JuMP.lower_bound(y)*x - JuMP.upper_bound(x)*JuMP.lower_bound(y)\n\n\n\n\n\n","category":"method"},{"location":"function_references/#LaplacianOpt.silence-Tuple{}","page":"Function References","title":"LaplacianOpt.silence","text":"Suppresses information and warning messages output by LaplacianOpt, for fine grained control use the Memento package\n\n\n\n\n\n","category":"method"},{"location":"function_references/#LaplacianOpt.variable_domain-Tuple{JuMP.VariableRef}","page":"Function References","title":"LaplacianOpt.variable_domain","text":"variable_domain(var::JuMP.VariableRef)\n\nComputes the valid domain of a given JuMP variable taking into account bounds and the varaible's implicit bounds (e.g. binary).\n\n\n\n\n\n","category":"method"},{"location":"quickguide/#Quick-Start-Guide","page":"Quick Start guide","title":"Quick Start Guide","text":"","category":"section"},{"location":"quickguide/#Framework","page":"Quick Start guide","title":"Framework","text":"","category":"section"},{"location":"quickguide/","page":"Quick Start guide","title":"Quick Start guide","text":"Building on the recent success of Julia, JuMP and mixed-integer programming (MIP) solvers, LaplacianOpt, is an open-source toolkit for the problem of maximum algebraic connectivity augmentation on graphs. As illustrated in the figure below, LaplacianOpt is written in Julia, a relatively new and fast dynamic programming language used for technical computing with support for extensible type system and meta-programming. At a high level, this package provides an abstraction layer to achieve two primary goals:","category":"page"},{"location":"quickguide/","page":"Quick Start guide","title":"Quick Start guide","text":"To capture user-specified inputs, such as the number of vertices of the graph, adjacency matrices of existing and augmentation graphs, and an augmentation budget, and to build a JuMP model of an MIP formulation with convex relaxations, and \nTo extract, analyze and post-process the solution from the JuMP model and to provide optimal connected graphs with maximum algebraic connectivity.","category":"page"},{"location":"quickguide/","page":"Quick Start guide","title":"Quick Start guide","text":"<align=\"center\"/>\n<img width=\"550px\" class=\"display-light-only\" src=\"../assets/LOpt_framework.png\" alt=\"../assets/LOpt_framework.png\"/>","category":"page"},{"location":"quickguide/#Getting-started","page":"Quick Start guide","title":"Getting started","text":"","category":"section"},{"location":"quickguide/","page":"Quick Start guide","title":"Quick Start guide","text":"After the installation of LaplacianOpt and a MIP solver, Gurobi.jl (use GLPK for an open-source MIP solver), from the Julia package manager, provide user inputs based on your available graph data. LaplacianOpt supports input data either in the JSON format, or by directly providing a data dictionary. Here, is an example on providing a data dictionary as an input. However, check this example script for providing data inputs using JSON files. A sample optimization model to maximize the algebraic connectivity of the weighted graph's Laplacian via edge augmentation can be executed with a few lines of code as follows:","category":"page"},{"location":"quickguide/","page":"Quick Start guide","title":"Quick Start guide","text":"import LaplacianOpt as LOpt\nusing JuMP\nusing Gurobi\n\nfunction data()\n    data_dict = Dict{String, Any}()\n    data_dict[\"num_nodes\"] = 4\n\n    # Base graph with 3 existing edges (fixed). Note this graph can also be empty. \n    data_dict[\"adjacency_base_graph\"] = [0 2 0 0; 2 0 3 0; 0 3 0 4; 0 0 4 0]\n\n    # Augmentation graph with 3 candidate edges\n    data_dict[\"adjacency_augment_graph\"] = [0 0 4 8; 0 0 0 7; 4 0 0 0; 8 7 0 0]\n\n    # Augmentation budget on candidate edges\n    augment_budget = 2\n    return data_dict, augment_budget\nend\n\ndata_dict, augment_budget = data()\n\nparams = Dict{String, Any}(\n    \"data_dict\"           => data_dict,\n    \"augment_budget\"      => augment_budget\n    )\n\nlopt_optimizer = JuMP.optimizer_with_attributes(Gurobi.Optimizer, \"presolve\" => 1) \nresults = LOpt.run_LOpt(params, lopt_optimizer)","category":"page"},{"location":"quickguide/","page":"Quick Start guide","title":"Quick Start guide","text":"tip: Tip\nRun times of LaplacianOpt's mathematical optimization models are significantly faster using Gurobi as the underlying mixed-integer programming (MIP) solver. Note that this solver's individual-usage license is available free for academic purposes. ","category":"page"},{"location":"quickguide/#Extracting-results","page":"Quick Start guide","title":"Extracting results","text":"","category":"section"},{"location":"quickguide/","page":"Quick Start guide","title":"Quick Start guide","text":"The run commands (for example, run_LOpt) in LaplacianOpt return detailed results in the form of a dictionary. This dictionary can be used for further processing of the results. For example, for the given instance of a complete graph, the algorithm's runtime and the optimal objective value (maximum algebraic connectivity) can be accessed with,","category":"page"},{"location":"quickguide/","page":"Quick Start guide","title":"Quick Start guide","text":"results[\"solve_time\"]\nresults[\"objective\"]","category":"page"},{"location":"quickguide/","page":"Quick Start guide","title":"Quick Start guide","text":"The \"solution\" field contains detailed information about the solution produced by the optimization model. For example, one can obtain the edges of the optimal graph toplogy from the symmetric adjacency matrix with,","category":"page"},{"location":"quickguide/","page":"Quick Start guide","title":"Quick Start guide","text":"optimal_graph = LOpt.optimal_graph_edges(results[\"solution\"][\"z_var\"])","category":"page"},{"location":"quickguide/","page":"Quick Start guide","title":"Quick Start guide","text":"Further, algebraic connectivity and the Fiedler vector of the optimal graph topology (though can be applied on any graph topology) can be obtained from the adjacency matrix with,","category":"page"},{"location":"quickguide/","page":"Quick Start guide","title":"Quick Start guide","text":"data = LOpt.get_data(params)\nadjacency_matrix = data[\"adjacency_base_graph\"] + data[\"adjacency_augment_graph\"]\noptimal_adjacency = results[\"solution\"][\"z_var\"] .* adjacency_matrix \ngraph_data = LOpt.GraphData(optimal_adjacency)\nprintln(\"Algebraic connectivity: \", graph_data.ac)\nprintln(\"Fiedler vector: \", graph_data.fiedler)","category":"page"},{"location":"quickguide/#Visualizing-results","page":"Quick Start guide","title":"Visualizing results","text":"","category":"section"},{"location":"quickguide/","page":"Quick Start guide","title":"Quick Start guide","text":"LaplacianOpt also currently supports the visualization of optimal graphs layouts obtained from the results dictionary (from above. To do so, these are the two options: ","category":"page"},{"location":"quickguide/","page":"Quick Start guide","title":"Quick Start guide","text":"TikzGraphs package for a simple and quick visualization of the graph layout without support to include edge weights, which can be executed with ","category":"page"},{"location":"quickguide/","page":"Quick Start guide","title":"Quick Start guide","text":"data = LOpt.get_data(params)\nLOpt.visualize_solution(results, data, visualizing_tool = \"tikz\")","category":"page"},{"location":"quickguide/","page":"Quick Start guide","title":"Quick Start guide","text":"Graphviz package for better visualization of weighted graphs. To this end, LaplacianOpt generates the raw .dot file, which can be further visualized using the Graphviz software either via the direct installation on the computer or using an online front-end visualization GUI (for example, see Edotor). Dot files can be generated in LaplacianOpt with ","category":"page"},{"location":"quickguide/","page":"Quick Start guide","title":"Quick Start guide","text":"data = LOpt.get_data(params)\nLOpt.visualize_solution(results, data, visualizing_tool = \"graphviz\")","category":"page"},{"location":"quickguide/","page":"Quick Start guide","title":"Quick Start guide","text":"For example, on a weighted complete graph with 10 nodes in instance #1, the optimal spanning tree with maximum algebraic connectivity, out of 10^8 feasible solutions, obtained by LaplacianOpt (using Graphviz visualization) is shown below ","category":"page"},{"location":"quickguide/","page":"Quick Start guide","title":"Quick Start guide","text":"(Image: Optimal solution)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"<align=\"center\"/>\n<img width=\"650px\" class=\"display-light-only\" src=\"assets/docs_header.png\" alt=\"assets/docs_header.png\"/>\n<!-- <img width=\"650px\" class=\"display-dark-only\" src=\"assets/docs_header_dark.png\" alt=\"assets/docs_header.png\"/> -->","category":"page"},{"location":"#Documentation","page":"Introduction","title":"Documentation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"CurrentModule = LaplacianOpt","category":"page"},{"location":"#Overview","page":"Introduction","title":"Overview","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"LaplacianOpt is a Julia package which implements polyhedral relaxation-based algorithms for the maximimum algebraic connectivity augmentation problem on weighted graph Laplacians. More specifically, given a weighted base graph with existing edges (could be empty), a set of candidate weighted edges for augmentation, and an augmentation budget (K), this package finds a set of K edges to augment to the base graph such that the resulting graph has maximum algebraic conenctivity with optimality guarantees.  For example, given a base graph with N vertices and 0 edges, set of candidate edges which form a complete graph, and K = (N-1), this packages finds a spanning tree with maximum algebraic connectivity.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Algebraic connectivity is the second smallest eigenvalue of the graph Laplacian. The magnitude of this value reflects how well connected the overall graph is. This connectivity measure has been used in analyzing the robustness and synchronizability of complex networks, and in graph sparsification techniques. ","category":"page"},{"location":"#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"To use LaplacianOpt, first download and install Julia. Note that the current version of LaplacianOpt is compatible with Julia 1.0 and later. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The latest stable release of LaplacianOpt can be installed using the Julia package manager with","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"import Pkg\nPkg.add(\"LaplacianOpt\")","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"At least one mixed-integer programming solver is required for running LaplacianOpt. The well-known CPLEX or the Gurobi solver is highly recommended, as it is fast, scaleable and can be used to solve on fairly large-scale graphs. However, the open-source GLPK solver is also compatible with LaplacianOpt which can be installed via the package manager with","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"import Pkg\nPkg.add(\"GLPK\")","category":"page"},{"location":"#Unit-Tests","page":"Introduction","title":"Unit Tests","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"To run the tests in the package, run the following command after installing the LaplacianOpt package.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"import Pkg\nPkg.test(\"LaplacianOpt\")","category":"page"},{"location":"#Citing-LaplacianOpt","page":"Introduction","title":"Citing LaplacianOpt","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"If you find LaplacianOpt.jl useful in your work, we request you to cite the following papers [link-1] [link-2]: ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"@inproceedings{LOpt_ECC2015,\n  title={On maximizing algebraic connectivity of networks for various engineering applications},\n  author={Nagarajan, Harsha and Rathinam, Sivakumar and Darbha, Swaroop},\n  booktitle={European Control Conference (ECC)},\n  pages={1626--1632},\n  year={2015},\n  organization={IEEE}\n}\n\n@article{LOpt_ASME2015,\n  title={Synthesizing robust communication networks for unmanned aerial vehicles with resource constraints},\n  author={Nagarajan, Harsha and Rathinam, Sivakumar and Darbha, Swaroop},\n  journal={Journal of Dynamic Systems, Measurement, and Control},\n  volume={137},\n  number={6},\n  pages={061001},\n  year={2015},\n  publisher={American Society of Mechanical Engineers}\n}","category":"page"}]
}
